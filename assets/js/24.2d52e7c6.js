(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{302:function(t,s,a){"use strict";a.r(s);var e=a(14),_=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"_1-了解-git-如何保存信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-了解-git-如何保存信息"}},[t._v("#")]),t._v(" 1. 了解 "),s("code",[t._v("git")]),t._v(" 如何保存信息")]),t._v(" "),s("p",[t._v("在《认识 "),s("code",[t._v("Git")]),t._v("》一节中介绍了，"),s("code",[t._v("git")]),t._v("是 "),s("RouterLink",{attrs:{to:"/git/introduce.html#_2-1-直接存储快照"}},[t._v("直接存储快照")]),t._v("，即每一次提交都保存了当前项目的完整快照（之前也说了，不是真的完整的快照，那些未修改的仅仅做了一个指针引用之前的版本即可）。接下来稍微详细的理解 "),s("code",[t._v("git")]),t._v(" 是如何保存信息的。")],1),t._v(" "),s("h3",{attrs:{id:"_1-1-四个对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-四个对象"}},[t._v("#")]),t._v(" 1.1 四个对象")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("对象名称")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("快照对象（"),s("code",[t._v("blob")]),t._v("对象）")]),t._v(" "),s("td",[t._v("就是指文件的快照（有修改的则为新的文件快照对象，没有修改的则为上一次提交的文件快照对象）")])]),t._v(" "),s("tr",[s("td",[t._v("树对象")]),t._v(" "),s("td",[t._v("它记录当前提交的所有快照对象的检验和（哈希值）和目录结构")])]),t._v(" "),s("tr",[s("td",[t._v("提交对象")]),t._v(" "),s("td",[t._v("它包含了指向当前提交的树对象的指针，以及其他信息")])]),t._v(" "),s("tr",[s("td",[t._v("父对象")]),t._v(" "),s("td",[t._v("当前提交对象的另一个指向对象，首次提交没有父对象，可以理解为上一次的提交对象")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:"/asserts/git/commit-and-tree.png",alt:""}}),t._v("\n图示就是一个提交对象的大致结构。")]),t._v(" "),s("h3",{attrs:{id:"_1-2-提交对象之间的引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-提交对象之间的引用"}},[t._v("#")]),t._v(" 1.2 提交对象之间的引用")]),t._v(" "),s("p",[t._v("上一节说到，每个提交对象（除了首次提交）都指向另一个对象：父对象。"),s("br"),t._v("\n如果从宏观来看（不看每个提交对象细节，而看每个提交对象之间的关系），那么如下图所示：\n"),s("img",{attrs:{src:"/asserts/git/commits-and-parents.png",alt:""}}),t._v("\n图示中，第一次提交的为 "),s("code",[t._v("Snapshot A")]),t._v("，他没有父对象；第二次提交为 "),s("code",[t._v("Snapshot B")]),t._v("，它指向的父对象为 "),s("code",[t._v("Snapshot A")]),t._v("，以此类推。")]),t._v(" "),s("h2",{attrs:{id:"_2-分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-分支"}},[t._v("#")]),t._v(" 2. 分支")]),t._v(" "),s("p",[t._v("分支的本质仅仅是指向提交对象的可变指针。"),s("br"),t._v("\n每个仓库，都有一个默认的分支（"),s("code",[t._v("master")]),t._v(" 或 "),s("code",[t._v("main")]),t._v("）。"),s("br"),t._v("\n它包含两个关键点：")]),t._v(" "),s("ul",[s("li",[t._v("指向提交对象")]),t._v(" "),s("li",[t._v("可变指针\n也就是说，分支总是指向提交对象的，并且它很有可能随时在变化，上一刻指向一个提交对象，下一刻又指向另一个提交对象。"),s("br"),t._v("\n那么，分支的可变情况到底是如何进行的呢？"),s("br"),t._v("\n原则就是：分支指向当前最新的提交对象。即每次提交，产生提交对象，那么分支则指向当前提交对象，以此类推的话，它会跟着提交对象向前移动。")])]),t._v(" "),s("h3",{attrs:{id:"_2-1-创建分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-创建分支"}},[t._v("#")]),t._v(" 2.1 创建分支")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("创建分支，是基于“当前提交对象”来创建的。"),s("br"),t._v("\n通常我们会说创建分支是在某某分支上切出一个分支，是不严谨的。")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch branchname\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch testing\n")])])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("创建分支，仅仅在当前提交对象上创建了一个新的分支，但是工作分支并没有切换到新的分支上，除非手动切换。")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-head-指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-head-指针"}},[t._v("#")]),t._v(" 2.2 "),s("code",[t._v("HEAD")]),t._v(" 指针")]),t._v(" "),s("p",[t._v("如上如果创建了一个新的分支，现在至少就存在两个分支："),s("code",[t._v("master")]),t._v(" 和 "),s("code",[t._v("testing")]),t._v("。那么 "),s("code",[t._v("git")]),t._v(" 是如何知道当前是在哪个分支上工作呢？"),s("br"),t._v(" "),s("code",[t._v("git")]),t._v(" 内部还又一个特殊的指针，它指向了当前工作分支，名为 "),s("code",[t._v("HEAD")]),t._v("。\n如果仅仅是创建分支，那么如下图所示，工作分支还是在 "),s("code",[t._v("master")]),t._v(" 上：\n"),s("img",{attrs:{src:"/asserts/git/head-to-master.png",alt:""}})]),t._v(" "),s("p",[t._v("要将工作分支切换到新的分支，即需要将 "),s("code",[t._v("HEAD")]),t._v(" 指针指向新的分支，需要切换分支。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-切换分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-切换分支"}},[t._v("#")]),t._v(" 2.3 切换分支")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout branchname\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout testing\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 或者在创建分支的时候同时切换到新的分支")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-b")]),t._v(" testing\n")])])]),s("p",[t._v("此时，工作分支才真的为新的分支，"),s("code",[t._v("HEAD")]),t._v(" 才指向新的分支：\n"),s("img",{attrs:{src:"/asserts/git/head-to-testing.png",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"_2-4-基于分支的提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-基于分支的提交"}},[t._v("#")]),t._v(" 2.4 基于分支的提交")]),t._v(" "),s("p",[t._v("所有的提交，都是基于当前工作分支的，那么当存在多个分支时，就存在一个场景：某些分支的版本停留在它提交的时候；而切出的新的分支一直在提交，版本比其他分支更新：\n"),s("img",{attrs:{src:"/asserts/git/advance-testing.png",alt:""}}),t._v("\n图示中可以看到，"),s("code",[t._v("master")]),t._v(" 分支保存的数据还是在上一个提交版本，而新的分支已经更新了版本。"),s("br"),t._v("\n再回过头来理解上面介绍的 "),s("code",[t._v("git")]),t._v(" 保存信息。每个提交对象指向了当时提交的树对象，树对象指向了当时提交的文件快照。"),s("br"),t._v("\n那么图示中对于 "),s("code",[t._v("master")]),t._v(" 分支来说，它此时保存的信息就是那个提交对象时的数据，比 "),s("code",[t._v("testing")]),t._v(" 当前提交对象保存的信息要落后版本，可以通过再次切换分支到 "),s("code",[t._v("master")]),t._v(" 上查看，会发现新提交的数据看不到了。")]),t._v(" "),s("h3",{attrs:{id:"_2-5-分支分叉"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-分支分叉"}},[t._v("#")]),t._v(" 2.5 分支分叉")]),t._v(" "),s("p",[t._v("现在假设基于上图的情况，切换到了 "),s("code",[t._v("master")]),t._v(" 分支，并且在当前分支（"),s("code",[t._v("master")]),t._v("）上再做修改，就会发现一个特别的情况，在某个提交对象上，"),s("code",[t._v("master")]),t._v(" 和 "),s("code",[t._v("testing")]),t._v(" 分支基于那个提交对象产生了分叉：\n"),s("img",{attrs:{src:"/asserts/git/advance-master.png",alt:""}}),t._v("\n其实可以同理理解，就算不是在同一个提交对象上进行不同分支的提交，总之会产生分叉分支的。"),s("br"),t._v("\n这个时候就有问题了，如果既需要 "),s("code",[t._v("master")]),t._v(" 分支上最新的提交，又需要 "),s("code",[t._v("testing")]),t._v(" 分支上最新的提交；或者说（针对上上一个图，即刚切换到 "),s("code",[t._v("master")]),t._v(" 分支，还未提交新的版本前）切换回旧分支时也需要新分支上的提交，此时该怎么办？那就需要分支合并了。")]),t._v(" "),s("h3",{attrs:{id:"_2-6-分支合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-分支合并"}},[t._v("#")]),t._v(" 2.6 分支合并")]),t._v(" "),s("p",[t._v("同样以上述图示的形式来理解分支合并。"),s("br"),t._v("\n假设这样的场景："),s("br"),t._v("\n当前在 "),s("code",[t._v("master")]),t._v(" 分支上。"),s("br"),t._v("\n然后基于最新的提交对象切出了一个新的分支 "),s("code",[t._v("testing")]),t._v("，在 "),s("code",[t._v("testing")]),t._v(" 分支上不断的提交前进。"),s("br"),t._v("\n现在突然来了一个需求，要求立马修复一个 "),s("code",[t._v("bug")]),t._v("，那么，此时 "),s("code",[t._v("testing")]),t._v(" 上的工作如果完成了，那么可以切换到 "),s("code",[t._v("master")]),t._v(" 分支，然后合并 "),s("code",[t._v("testing")]),t._v(" 上的所有修改，然后切出新的分支修复 "),s("code",[t._v("bug")]),t._v("，甚至都不用合并再切新的分支，只需要继续在 "),s("code",[t._v("testing")]),t._v(" 分支上修复 "),s("code",[t._v("bug")]),t._v(" 就行（但是这种做法对于测试、发布流程不严格要求的情况才行，否则针对每一个版本都需要严格测试、严格发布的还是必须切新的分支）。"),s("br"),t._v("\n但如果 "),s("code",[t._v("testing")]),t._v(" 分支上的开发并没有完成，还不能上线，那么就必须要暂时停止 "),s("code",[t._v("testing")]),t._v(" 上的工作然后切出新的分支立马修复 "),s("code",[t._v("bug")]),t._v("。此时应该将 "),s("code",[t._v("testing")]),t._v(" 分支上的已修改、已暂存的数据保存，有两种做法，一种直接提交，一种 "),s("code",[t._v("stash")]),t._v(" 缓存（后续学习），这是因为在切换分支时，如果不保持当前分支的干净状态（还有已修改、已暂存）那么切换可能不成功，就算切换成功了可能导致不应该出现了修改出现在了新切出的分支上。"),s("br"),t._v("\n此时如果保持了 "),s("code",[t._v("testing")]),t._v(" 分支上没有已修改、已暂存的数据，那么切换到 "),s("code",[t._v("master")]),t._v(" 分支，然后再基于 "),s("code",[t._v("master")]),t._v(" 分支的最新提交对象切出一个新的分支 "),s("code",[t._v("fix")]),t._v(" 分支，然后在该分支上不断提交。")]),t._v(" "),s("p",[t._v("这个场景如果以图示来看的话，类似如下：\n"),s("img",{attrs:{src:"/asserts/git/basic-branching-4.png",alt:""}})]),t._v(" "),s("p",[t._v("接下来就是分支合并了：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge branchname\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 假设修复 bug 的分支已经完成提交")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout master\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge fix\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-d")]),t._v(" fix\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" commit "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'修复 bug'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" push\n")])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("一般来说，如果时临时分支，合并后应该删除。")])]),t._v(" "),s("p",[t._v("此时图示如下：\n"),s("img",{attrs:{src:"/asserts/git/basic-branching-6.png",alt:""}})]),t._v(" "),s("p",[t._v("分支合并可能涉及到同一个前进方向上的合并（快速合并），也可能涉及分叉的合并，这些涉及核心知识；还有可能在合并后产生冲突，遇到解决即可。")]),t._v(" "),s("h3",{attrs:{id:"_2-7-删除分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-删除分支"}},[t._v("#")]),t._v(" 2.7 删除分支")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 要删除的分支上没有已修改、已暂存，切换到其它分支上后删除")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout master\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-d")]),t._v(" branchname\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 要删除的分支上有已修改、已暂存")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 要么先切换到该分支，然后提交，然后切换到其他分支上进行删除")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout needDelete\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" commit "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout master\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-d")]),t._v(" needDelete\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 要么直接强制删除，即放弃那个分支上的所有修改")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout master\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-D")]),t._v(" needDelete\n")])])])])}),[],!1,null,null,null);s.default=_.exports}}]);